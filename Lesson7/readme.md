### Tasks description for Lesson 7:

#### Комментарии:

Задание к уроку 7 выполнено, прошу прощения за задержку

В соответствии с замечанием к уроку 4, я разделил сервис отправки писем на две части. MailSender теперь является универсальным классом для отправки писем вообще (и я его перенес в отдельный namespace MailServices, не связанный с ProductCatalog), а NotificationDispatcher - это уже сервис отправки сообщений конкретно для нашего проекта, поэтому он уже сам "знает", кому отправлять письма и знает, какие сообщения с каким приоритетом отправлять (об ошибках немедленно, а об изменениях в каталоге - накапливать в очереди).

Вопрос lifetime я обдумал тщательно, но все решил оставить MailSender синглетоном. Дело в том, что, по-моему, этот сервис должен быть асинхронным относительно пользователя - пользователь не должен ждать, пока письмо отправится. Поэтому я и сделал решение типа "выстрелить и забыть" с

    _ = SendMailAsync()

чтобы задача создавалась на "автономное" выполнение, а управление контроллеру возвращалось немедленно и он немедленно отдавал ответ пользователю. И я понимаю, что в этом случае не получится обработать исключения - но, честно говоря, по-моему, в данном случае их и не надо выносить на верхний уровень. Если оповещение отправить не получилось, это наше внутреннее дело, а пользователя это не касается. Поэтому, мне кажется, обработка ошибок отправки писем должна быть замкнута внутри сервиса отправки.

А дальше я решил оставить реализацию с накоплением писем в очереди и отправкой "пачками"; я прошу прощения, что опять не соглашаюсь, но, честно говоря, мне это кажется более правильным решением, чем троттлинг. Точнее - зависит от ситуации. Троттлинг поможет, если нагрузка неравномерная, и происходят короткие всплески с отправкой большого количества оповещений, за которыми идут длинные паузы. Если же сервер постоянно хочет отправлять, скажем, тысячу оповещений каждый час, а почта пропускает всего 50 - троттлинг "захлебнется", его очередь просто будет расти и расти. Система же группировки писем в пачки способна "переварить" любое количество оповещений.

Но система с группировкой писем (как и система с троттлингом) уже "совсем асинхронны" - в них фактическая отправка письма в принципе может произойти через значительное время после запроса. Поэтому в этой системе, по-моему, уж точно надо замыкать обработку ошибок внутри сервиса отправки, а пользователю возвращать управление немедленно.

И я переделал мой сервис в BackgroundTask. И отправку сообщений каждый час я вставил в него же, надеюсь, это не проблема. Но, к сожалению, проблемой является то, что я настроил проект для Net 3.1, а Net 6 в моей Visual Studio 2019 даже и не установлен. Поэтому мне не удалось задействовать PeriodicTimer, я сделал Delay на 5 минут - хотя и понимаю, что так точность ниже.

Дальше у меня возникла проблема с обращением к этой фоновой задаче. Как я понял, она задумана, чтобы работать сама по себе; а я хотел дать ей интерфейс и использовать через DI. Это оказалось не так просто, и сначала я даже соорудил дурацкий суррогат из статических методов, но потом нашел в Интернете правильное (хотя и не очень простое) решение.
Вот здесь я его нашел:

https://stackoverflow.com/questions/51254053/how-to-inject-a-reference-to-a-specific-ihostedservice-implementation

буду благодарен за совет, если есть более простой способ.

И, конечно, это можно сделать проще через Domain Events - и в уроке 8 я так и сделаю :)  Но в этом уроке мы их еще формально не проходили, и мне хотелось найти решение через DI.

Передачу CancellationToken во все методы я сделал, хотя применение им, честно говоря, нашел с трудом. Дело в том, что все методы синхронные, поскольку работают не с базой данных, а с коллекциями. И я не знаю, сработает ли в таком случае CancellationToken. Но я все же сделал проверку на него в итераторах - если вдруг в каталоге будут миллионы наименований, и пользователь заскучает и закроет страницу - надеюсь, CancellationToken тогда прервет генерацию страницы.

А вот в отправку сообщений я этот CancellationToken передавать не стал - по той причине, что, опять же, это наше дело, и пользователя не касается. Точнее, если пользователь прервет запрос до того, как каталог будет изменен - тогда исключение по прерыванию будет вызвано до вызова отправки оповещения, и до него дело все равно не дойдет. А вот если каталог успел измениться, и пользователь отправил прерывание уже во время генерации ответной страницы - тогда сообщение нам все равно отправить надо.

--------------------------------------------------------------------------------------------------

Добавление: я установил Visual Studio 2022, поменял проект на Net 6 и сделал PeriodicTimer. Но столкнулся с другой проблемой: я у моего BackgroundService периодической отправки сообщений поставил также отправку сообщений при активации CancellationToken, чтобы при закрытии приложения форсировать отправку всего накопившегося в очереди. Но обнаружил, что при закрытии приложения сервис завершается без получения Cancellation. Поэтому я добавил DisposeAsync, в котором эта отправка также вызывается. Зато вот появился повод и DisposeAsync применить и показать, что я его тоже освоил :)
