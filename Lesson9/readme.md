### Tasks description for Lesson 9:

#### Комментарии:

Задание к уроку 9 выполнено.

1. Блокировку браузеров по UserAgent я написал по лекции. Признаюсь, не придумал, что бы еще сделать оригинального.

2. Логирование добавлено, понадобилось всего две строчки - AddHttpLogging и UseHttpLogging. Только я не смог сделать, как в примерах

        builder.Services.AddHttpLogging(...);
        var app = builder.Build();
        app.UseHttpLogging();

поскольку у меня вся настройка конвейера use...() делается в Startup.cs, а там у меня не было builder. Так что я сделал все в разных методах - AddHttpLogging в Startup.ConfigureServices(...), где есть доступ к services, а app.UseHttpLogging - в Startup.Configure(...), где есть app. И так все заработало.

3. Для метрик посещения страниц сайта я сделал маленькую библиотеку, которая находится в папке Metrics. Она включает в себя хранилище данных MetricsStorage с функцией "увеличить счетчик" и энумератором сохраненных данных, Middleware-класс MetricsCounter и контроллер MetricsController. К контроллеру прилагается еще View в папке Views\Metrics\Index.cshtml. Я нашел в документации Microsoft, что надо назвать действие Index, тогда оно будет доступно по ссылке /metrics, как требовалось в задании, а не /metrics/действие.

Я не стал распределять файлы по папкам Controller/Model/Service, а оставил все в одной, поскольку они образуют самостоятельную библиотеку. В принципе даже пригодную к интеграции в любой проект - для этого надо просто в его инициализацию добавить

        services.AddSingleton<IMetricsStorage, MetricsStorage>();
        app.UseMiddleware<MetricsCounter>();

и добавить ссылку на /metrics в меню сайта.

При этом я включил app.UseMiddleware<MetricsCounter>() в самое начало конвейера, еще до UseHttpsRedirection, чтобы подсчитывались именно самые исходные ссылки - что непосредственно вводил пользователь.

В MetricsStorage я предпринял некоторые ухищрения для потокобезопасной работы. Данные хранятся в ConcurrentDictionary, а Path используется как индекс. При этом сам счетчик хранится не непосредственно как int, а как объект с int внутри. Таким образом, для увеличения счетчика не надо делать "извлечь-увеличить-сохранить", что сложнее сделать потокобезопасным. Вместо этого я получаю указатель на класс и увеличиваю int внутри с помощью Interlocked.Increment - что должно сработать аккуратно даже при одновременном обращении из нескольких потоков. А при добавлении я не стал использовать GetOrAdd, чтобы не замусоривать кучу лишними экземплярами IntObject. Вместо этого я сначала пробую TryGet, а если не удалось - тогда уже TryAdd с новым экземпляром. Если два потока попытаются одновременно сделать TryAdd, у одного не получится, и его экземпляр IntObject останется лишним - но все же так будет меньше мусора; а потом оба снова попробуют TryGet, получат уже один и тот же экземпляр объекта и корректно увеличат int внутри него через Interlocked.Increment. А вот энумераторы возвращают данные уже в виде простых структур { string Path; int Counter; }.

4. В духе урока я решил переделать обработку исключений из фильтра в Middleware. Но оказалось, что ничего добавлять не надо - этим уже занимается HomeController.Error, так что я перенес в него мой код обработки - с отправкой оповещения через MailSender.

5. Я доработал обработку исключений MailSender как было показано на лекции.
