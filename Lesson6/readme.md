### Tasks description for Lesson 6:

#### Комментарии:

Задание к уроку 6 выполнено.

Фактически, к прошлому уроку я уже сделал отправку сообщений асинхронной, но тогда сделал к ней синхронную обертку. Но после последней лекции я понял, что это не лучшая идея, и переделал вызов в

    _ = SendNotificationAsync(message);

Ждать отправки сообщения в каком бы то ни было месте контроллера - идея плохая, поскольку нам нужно как можно быстрее вернуть пользователю страницу. Поэтому я просто создаю задачу в режиме "создать и забыть" - и, возможно, она отработает и отправит сообщение уже после завершения контроллера. А возможные проблемы обрабатывает сервис SendNotificationAsync, в котором в прошлый раз через Polly было сделано три попытки, и дальше при неудаче можно добавлять отправку какого-то еще оповещения (SMS или что-то еще) - но, в общем, это уже дело сервиса, а контроллер просто создает асинхронную задачу и возвращается к своим делам.

Но после этого я обеспокоился, можно ли оставить MailNotifier Scoped - не будет ли он в этом случае уничтожен с завершением контроллера и его Scope'а до того, как успеет отправить сообщение? Возможно, я зря беспокоился, но четкой информации о времени жизни асинхронных объектов, созданных из Scoped-объекта, и будут ли они жить после завершения Scope, я не нашел. Везде в Интернете про Lifetime пишут о правилах создания DI объектов, но не о правилах уничтожения. Поэтому я подумал было сделать MailNotifier Transient - тем более, что контроллер может ведь захотеть отправить и несколько емейлов за время обработки одного запроса, и тогда - поскольку теперь отправка асинхронная, и несколько отправок могут быть инициированы параллельно - лучше создавать новый MailNotifier на каждое сообщение.

Но после разбора ДЗ в последней части лекции я понял, что MailNotifier, наоборот, может быть Singleton. На каждый запрос он создает новый асинхронный объект Task, и внутри каждого Таска создается свой SmtpClient - и они могут жить параллельно своей жизнью, а сам по себе MailNotifier потокобезопасен и может быть один.

А потом я задумался над еще одним вопросом. Не будет ли проблемой для почтового сервера, если мы одновременно создадим несколько SmtpClient'ов, и они начнут параллельно к нему коннектиться и что-то отправлять с одного IP?  И, тем более, вдруг наш сервис станет популярным, и мы захотим отправлять сотни оповещений в секунду с одного адреса - нас забанят :)  Поэтому я решил сделать еще одну вещь - уже немножко за пределами ДЗ, но, по-моему, тоже в русле нашей темы. Синхронизировать эту асинхронную отправку и сделать, чтобы контроллеры могли отправлять запросы на отправку сообщений одновременно и вразнобой, но потом сервис все отправлял по порядку. А заодно я подумал, что тогда уж лучше объединять несколько сообщений в одно, чтобы не спамить.

Благо решение для этого придумалось совсем простое - ConcurrentQueue, я прочитал об этой структуре на одном из прошлых уроков, когда изучал встроенные потокобезопасные структуры данных. Теперь SendNotification добавляет сообщения в эту очередь и сразу завершается. А потом отдельная задача - процессор сообщений (которая создается в конструкторе MailNotifier и живет все время жизни приложения - благо MailNotifier теперь Singleton!) каждые пять минут забирает из очереди все сообщения, собирает через StringBuilder в одну строку и отправляет одним письмом. И при этом ожидание этих 5 минут я сделал через await Task.Delay, как и отправка деляется через await SendNotificationAsync, так что в целом процессор сообщений тоже должен быть эффективен и по-минимуму занимать потоковые ресурсы.

Правда, сообщения за последние пять минут перед закрытием программы могут потеряться. Для обработки этого можно в Program.cs в finally (там, где закрывается лог) добавить форсированную отправку всего накопившегося - но я уже не стал этого делать. Поскольку, честно говоря, пример учебный, и я хотел проверить идею, а не загромождать код. Простите :)  Но сама идея с группировкой сообщений заработала и мне нравится.

И также я оставил и старый вариант с немедленной отправкой email, это функция SendUrgentNotification. Я применяю ее так: если в контроллере обнаруживается ошибка в программе (неожиданное исключение) - сообщение о нем отправляется через SendUrgentNotification. А вот обычные "рабочие" сообщения о добавлении/удалении товаров и категорий отправляются через обычный SendNotification, который их группирует и отправляет пачками раз в пять минут.

--------------------------------------------------------------------

Упражнение по чтению файлов также сделано, в проекте MultiFileRead. Соответствующий метод я сделал прямо в Program. Правда, система не позволила мне сделать метод Program.Main async, поэтому не получилось красиво использовать await и пришлось вызывать асинхронный метод синхронным образом (получая задачу, ожидая завершения через Wait и забирая результат из Result).