### Tasks description for Lesson 8:

#### Комментарии:

Задание к уроку 8 выполнено.

Я решил не копировать дословно решение из лекций, а попробовать сделать что-то оригинальное. Надеюсь, вы это примете.

Мне захотелось сделать поддержку иерархии событий. В частности, у меня в программе создается класс CatalogChangeEvent, от которого наследуются CatalogAddProductEvent, CatalogUpdateProductEvent и так далее. Но при этом подписчик событий может подписаться как на конкретный класс-событие, так и на общий CatalogChangeEvent. То есть, диспетчер событий должен вызывать обработчики, подписанные как на случившееся событие, так и на его предков в иерархии объектов. Мне кажется, это в духе ООП, это гибко и полезно, и просто интересно реализовать.

Но в этом случае для хранения обработчиков уже не подойдет Dictionary, поэтому я воспользовался старой наработкой - самодельным потокобезопасным односвязным списком, сделанным в одном из предыдущих домашних заданий. Я исходил из того, что подписываться на события классы будут редко - и, на самом деле, вообще только при запуске программы. Ведь, поскольку мы не реализовывали удаление обработчиков, Scoped и Transient объекты подписываться не могут - начнутся проблемы, когда они исчезнут. Доменные события - для Singelton'ов; но они вполне могут и подписаться при своем создании в начале работы. Поэтому можно даже считать, что подписываются они в однопоточной среде; я для безопасности обернул запись в lock, но это должно быть неважно.

Зато потом, во время основной работы программы, чтение готового списка уже потокобезопасно!  И, как я понимаю, эффективней, чем конкурентные коллекции. Правда, насколько я понимаю, Dictionary эффективней моего перебора (я читал, что Dictionary внутри использует дерево). Так что, если событий и подписчиков будет много, мое решение окажется неэффективным - но в небольшой программе, по-моему, будет работать неплохо. И, сравнивая каждый обработчик со случившимся событием через IsInstanceOfType, я обеспечиваю желаемую поддержку иерархии событий.

Все остальное вполне прямолинейно. DomainEventDispatcher я сделал не статическим классом, а Singleton'ом, и все его пользователи подписываются на него через DI. В частности, NotificationService подписывается на два разных события - изменение в каталоге и ошибку в программе - двумя разными обработчиками, и по первому событию реализует сборку оповещений в блоки, а сообщения об ошибках отправляет немедленно. И при этом событие "изменение в каталоге" распадается на шесть разных подсобытий - так что, если зачем-то еще их понадобится обработать раздельно, на них вполне можно подписываться и по отдельности. А NotificationService подписывается на них сразу на все благодаря поддержке иерархии.

Я хотел еще сделать фильтры исключений, но не успел. В обязательных заданиях их и не было, так что обязательную часть я сделал, но мне просто хочется :)  Может быть, доделаю в уроке 8 и перезалью, или сделаю уже в финальном проекте.

--------------------------------------------------------------------------------------------------

Добавления:

1. Те же изменения, что и в уроке 7 - после установки Visual Studio 2022 и перевода проекта на Net 6 я подключил PeriodicTimer.

2. Я сообразил, как сделать потокобезопасное добавление в односвязный список без lock - через Interlocked.CompareExchange. Надеюсь, придумал правильно - вроде, работает.

3. Я все же беспокоился о том, чтобы более надежно обрабатывать ошибки в MailSender, которые не передаются наверх. Поэтому сделал следующее: помимо отправки почты, сообщения также пишутся в файл - как резервный вариант. В настройках можно указать, записывать ли все сообщения, либо только неотправленные, либо ничего. Таким образом, если почта перестанет работать, оповещения сохранятся в файле. Конечно, все это и в лог идет, но лог - он для программиста, он сложный, и там много другой информации. А это файл для администратора сервиса, который сможет прочитать все пропущенные оповещения о событиях в каталоге, если его почта перестала работать.

4. Я добавил в контроллер ExceptionFilter. При этом исключение CatalogException контроллер обрабатывает сам, поскольку при этом запрос в целом выполняется, просто в середину ответа вставляется замечание об ошибке - и это я не знаю, как сделать фильтром. А вот другие исключения передаются в фильтр и там выдается сообщение об ошибке. В отладочной среде выдается в ответе, а иначе отправляется администратору через Notification, а пользователю сообщается, что произошла ошибка.
