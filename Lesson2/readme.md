### Tasks description for Lesson 2:

#### Комментарии:

Задание к уроку 2 выполнено.

1. Сделана библиотека ConcurrentList.
При ее реализации приняты следующие решения
- в основе коллекции лежит простой односвязный список
- чтение коллекции осуществляется без блокировок за счет того, что она всегда поддерживается в корректном состоянии. Это возможно благодаря тому, что запись ссылки - атомарная операция в C#
- удаление элементов осуществляется простой установкой флага "удален" и тоже делается без блокировок. Соответственно, есть возможность их восстановить. При этом имеется метод Purge, который проходит по всему списку и фактически удаляет помеченные к удалению элементы. Этот метод блокирует запись (но не чтение)
- итератор по коллекции пропускает элементы, помеченные как удаленные
Мне эта реализация кажется довольно эффективной.

Я не придумал, как сделать корректную в условиях многопоточности сортировку - при этом так, чтобы, например, "пойманные" на середине процесса итераторы в других потоках отработали корректно, не пропустив переставленные элементы или не пойдя по уже отработанным заново. Поэтому для сортировки предлагается два решения:
- метод Snapshot создает "снимок" текущего состояния коллекции как обычный List (причем можно указать фильтр и выбрать часть значений). Это довольно эффективно, поскольку сами объекты не копируются - только ссылки. Дальше этот Snapshot уже можно отсортировать как угодно обычным List.Sort().
- можно сделать "постоянно отсортированную" коллекцию. Для этого сделан вариант ConcurrentListSorted, которому при создании передается правило сортировки, и дальше все добавляемые элементы вставляются в список корректно на нужные места, так что он постоянно поддерживается отсортированным. При этом с него все равно можно сделать SnapShot - и, например, отсортировать по другому критерию.

Метод Insert для отсортированной коллекции правильно работает у условиях многопоточности и возможных одновременных вставок из нескольких потоков. При этом для усорения он сначала находит нужное место в списке, не блокируя семафор. Потом блокирует, при необходимости (если коллекция успела измениться из другого потока) корректирует место вставки и вставляет. С удалением же Insert совместим просто - элементы вставляются в единый корректный список вместе с помеченными к удалению (так что возможное последующее восстановление сохранит коллекцию отсортированной). А вот метод Purge() корректность логики вставки нарушает, поэтому, если Insert обнаружил случившийся Purge, он перезапускает вставку сначала. Но предполагается, что вызовы Purge() и такие коллизии будут редкими.

2. Для теста сделано простое консольное приложение.
Оно оперирует коллекцией точек на плоскости (x,y), отсортированной по X. В коллекцию из двух потоков добавляется 10 точек с постоянной печатью, затем несколько удаляется, потом с коллекции делается снэпшот и печатается с сортировкой по Y. Все работает ожидаемо.

3. Catalog переведен на использование новой коллекции и тоже работает.

--------

Библиотека была переработана для совместимости с принятым в C# интерфейсом ICollection. Обе версии коллекции объединены в одну, теперь при создании можно задать правило сортировки - тогда коллекция будет отсортированной - а можно не задавать.
